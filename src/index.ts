import fsExtra from "fs-extra";
import path from "path";
import { version } from "../package.json";
import { Bundle, GenerateResult, templateId } from "./bundle";
import { MessageId, ParamId, ParamType, validateLocaleId, validateMessageId /*validateParamType*/ } from "./types";
import { CodegenTypes } from "./codegen";

const BANNER =
  `
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck

// DO NOT MODIFY
// FILE GENERATED BY \`intl-codegen@${version}\`
// https://github.com/eversport/intl-codegen
// DO NOT MODIFY
`.trim() + "\n\n";

interface InputParameter {
  /** Name of the parameter */
  name: string;
  /**
   * The type of parameter.
   * This can be either the builtin `"string"`, `"number"`, `"datetime"`, `"monetary"`, `"element"`,
   * or any of the custom types defined using `defineType`.
   * It will default to `"string"`, which is strongly type-checked.
   */
  type?: string;
}

export { CodegenTypes };

export class IntlCodegen {
  private bundle = new Bundle();

  /**
   * Define a custom enum type with `name` and `variants` for use inside selectors.
   */
  // defineType(name: string, variants: Array<string>): IntlCodegen {
  //   this.bundle.addType(validateParamType(name), variants);

  //   return this;
  // }

  /**
   * Define a single message with `id` and `params`, with the fallback template in
   * `MessageFormat` syntax.
   */
  defineMessageUsingMessageFormat(id: string, messageFormat: string, params: Array<InputParameter> = []): IntlCodegen {
    const parsedParams = new Map(
      params.map(p => {
        const name = p.name as ParamId;
        const type = (p.type || "string") as ParamType;
        return [name, { name, type }];
      }),
    );

    this.bundle.addMessageFormat(templateId, id as MessageId, messageFormat, parsedParams);

    return this;
  }

  /**
   * Defines multiple messages at once using `fluent` syntax.
   * Message `id`s and `params` are extracted directly from the `fluent` syntax
   * using a tsdoc-like comments.
   * See https://github.com/projectfluent/fluent/issues/140
   */
  defineMessagesUsingFluent(fluent: string): IntlCodegen {
    this.bundle.addFluentMessages(templateId, fluent);

    return this;
  }

  /**
   * This adds a localized message using `MessageFormat` syntax in the specified `locale`
   * for the previously defined Message with the matching `id`.
   */
  addLocalizedMessageUsingMessageFormat(locale: string, id: string, messageFormat: string): IntlCodegen {
    this.bundle.addMessageFormat(validateLocaleId(locale), validateMessageId(id), messageFormat);

    return this;
  }

  /**
   * This adds multiple localized messages at once using `fluent` syntax in the specified `locale`.
   */
  addLocalizedMessagesUsingFluent(locale: string, fluent: string): IntlCodegen {
    this.bundle.addFluentMessages(validateLocaleId(locale), fluent);

    return this;
  }

  /**
   * This will run the actual parsing, type checking and code generation.
   * It will return an Array of `files` and `errors`.
   */
  async generate(output: Array<CodegenTypes> = [CodegenTypes.Js, CodegenTypes.React]): Promise<GenerateResult> {
    const outputs = new Set(output);
    // react implies js
    if (outputs.has(CodegenTypes.React)) {
      outputs.add(CodegenTypes.Js);
    }

    const result = await this.bundle.generate(outputs, path.sep || "/");

    for (const file of result.files) {
      file.content = BANNER + file.content;
    }

    return result;
  }

  /**
   * This will generate all the code, and additionally write out all the files
   * to `dir`.
   */
  async write(dir: string, output?: Array<CodegenTypes>): Promise<GenerateResult> {
    const result = await this.generate(output);

    for (const file of result.files) {
      await fsExtra.outputFile(path.join(dir, file.path), file.content);
    }

    return result;
  }
}

export default IntlCodegen;
